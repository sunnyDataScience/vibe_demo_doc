# âš¡ ç·¨ç¨‹å¯¦ä½œæŒ‡å—ï¼šé€æ­¥ç·¨å¯«ç¨‹å¼ç¢¼

## ğŸ¯ å¯¦ä½œç­–ç•¥ï¼šå¾ç°¡å–®åˆ°è¤‡é›œ

### ğŸƒâ€â™‚ï¸ ç¬¬ä¸€é€±ï¼šMVPæ ¸å¿ƒåŠŸèƒ½
**ç›®æ¨™**ï¼šå»ºç«‹æœ€åŸºæœ¬çš„æ–°èæ‘˜è¦åŠŸèƒ½

#### Day 1-2: å°ˆæ¡ˆåŸºç¤æ¶æ§‹
```bash
# 1. å»ºç«‹å°ˆæ¡ˆçµæ§‹
mkdir news-summary-extension
cd news-summary-extension

# 2. åˆå§‹åŒ–Git
git init
echo \"node_modules/\" > .gitignore

# 3. åˆå§‹åŒ–npmå°ˆæ¡ˆ
npm init -y

# 4. å»ºç«‹ç›®éŒ„çµæ§‹
mkdir -p frontend/{popup,background,content}
mkdir -p backend/{routes,services,models,config}
mkdir tests docs
```

#### Day 3-4: Chromeæ’ä»¶éª¨æ¶
å»ºç«‹ `frontend/manifest.json`ï¼š
```json
{
  \"manifest_version\": 3,
  \"name\": \"æ™ºèƒ½æ–°èæ‘˜è¦åŠ©æ‰‹\",
  \"version\": \"1.0.0\",
  \"description\": \"AIé©…å‹•çš„å€‹äººåŒ–æ–°èæ‘˜è¦å·¥å…·\",

  \"permissions\": [
    \"activeTab\",
    \"storage\",
    \"notifications\"
  ],

  \"action\": {
    \"default_popup\": \"popup/popup.html\",
    \"default_icon\": {
      \"16\": \"icons/icon16.png\",
      \"48\": \"icons/icon48.png\",
      \"128\": \"icons/icon128.png\"
    }
  },

  \"background\": {
    \"service_worker\": \"background/background.js\"
  },

  \"content_scripts\": [
    {
      \"matches\": [\"<all_urls>\"],
      \"js\": [\"content/content.js\"]
    }
  ]
}
```

å»ºç«‹ `frontend/popup/popup.html`ï¼š
```html
<!DOCTYPE html>
<html lang=\"zh-TW\">
<head>
    <meta charset=\"UTF-8\">
    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">
    <title>æ–°èæ‘˜è¦åŠ©æ‰‹</title>
    <link rel=\"stylesheet\" href=\"popup.css\">
</head>
<body>
    <div class=\"container\">
        <header>
            <h1>ğŸ“° æ–°èæ‘˜è¦åŠ©æ‰‹</h1>
        </header>

        <main>
            <div class=\"input-section\">
                <label for=\"urls\">æ–°èç¶²å€æ¸…å–®:</label>
                <textarea id=\"urls\" placeholder=\"è«‹è¼¸å…¥æ–°èç¶²å€ï¼Œæ¯è¡Œä¸€å€‹\"></textarea>

                <label for=\"prompt\">æ‘˜è¦åå¥½:</label>
                <select id=\"prompt\">
                    <option value=\"business\">å•†æ¥­è§’åº¦</option>
                    <option value=\"technical\">æŠ€è¡“è§’åº¦</option>
                    <option value=\"general\">ä¸€èˆ¬æ‘˜è¦</option>
                    <option value=\"custom\">è‡ªå®šç¾©</option>
                </select>

                <div id=\"custom-prompt\" class=\"hidden\">
                    <textarea id=\"custom-text\" placeholder=\"è«‹æè¿°æ‚¨çš„æ‘˜è¦éœ€æ±‚\"></textarea>
                </div>
            </div>

            <div class=\"action-section\">
                <button id=\"create-task\" class=\"btn-primary\">
                    ğŸš€ ç«‹å³ç”Ÿæˆæ‘˜è¦
                </button>
                <button id=\"schedule-task\" class=\"btn-secondary\">
                    â° è¨­å®šæ’ç¨‹
                </button>
            </div>

            <div id=\"status\" class=\"status-section hidden\">
                <div class=\"loading\">
                    <div class=\"spinner\"></div>
                    <span>æ­£åœ¨è™•ç†ä¸­...</span>
                </div>
            </div>

            <div id=\"result\" class=\"result-section hidden\">
                <h3>ğŸ“‹ æ‘˜è¦çµæœ</h3>
                <div id=\"summary-text\"></div>
                <div class=\"action-buttons\">
                    <button id=\"play-audio\" class=\"btn-audio\">ğŸµ èªéŸ³æ’­å ±</button>
                    <button id=\"view-references\" class=\"btn-ref\">ğŸ“– æŸ¥çœ‹åŸæ–‡</button>
                </div>
            </div>
        </main>
    </div>

    <script src=\"popup.js\"></script>
</body>
</html>
```

å»ºç«‹ `frontend/popup/popup.css`ï¼š
```css
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    width: 400px;
    min-height: 500px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

.container {
    padding: 20px;
    color: white;
}

header h1 {
    text-align: center;
    margin-bottom: 20px;
    font-size: 18px;
}

.input-section {
    margin-bottom: 20px;
}

label {
    display: block;
    margin-bottom: 5px;
    font-weight: 500;
}

textarea, select {
    width: 100%;
    padding: 10px;
    border: none;
    border-radius: 8px;
    margin-bottom: 15px;
    font-size: 14px;
    background: rgba(255, 255, 255, 0.9);
}

textarea {
    min-height: 80px;
    resize: vertical;
}

.hidden {
    display: none;
}

.action-section {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
}

button {
    flex: 1;
    padding: 12px;
    border: none;
    border-radius: 8px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
}

.btn-primary {
    background: #4CAF50;
    color: white;
}

.btn-secondary {
    background: #2196F3;
    color: white;
}

button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.status-section {
    text-align: center;
    padding: 20px;
}

.loading {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
}

.spinner {
    width: 20px;
    height: 20px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-top: 2px solid white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.result-section {
    background: rgba(255, 255, 255, 0.1);
    padding: 15px;
    border-radius: 10px;
    backdrop-filter: blur(10px);
}

#summary-text {
    background: white;
    color: #333;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 15px;
    max-height: 200px;
    overflow-y: auto;
    line-height: 1.5;
}

.action-buttons {
    display: flex;
    gap: 10px;
}

.btn-audio, .btn-ref {
    flex: 1;
    padding: 8px 12px;
    background: rgba(255, 255, 255, 0.2);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
}
```

#### Day 5-7: å‰ç«¯é‚è¼¯å¯¦ä½œ
å»ºç«‹ `frontend/popup/popup.js`ï¼š
```javascript
class NewsExtension {
    constructor() {
        this.apiBaseUrl = 'http://localhost:3000/api/v1';
        this.init();
    }

    init() {
        this.bindEvents();
        this.loadUserPreferences();
    }

    bindEvents() {
        // è‡ªå®šç¾©æç¤ºè©åˆ‡æ›
        document.getElementById('prompt').addEventListener('change', (e) => {
            const customPrompt = document.getElementById('custom-prompt');
            if (e.target.value === 'custom') {
                customPrompt.classList.remove('hidden');
            } else {
                customPrompt.classList.add('hidden');
            }
        });

        // å‰µå»ºä»»å‹™æŒ‰éˆ•
        document.getElementById('create-task').addEventListener('click', () => {
            this.createTask('immediate');
        });

        // æ’ç¨‹ä»»å‹™æŒ‰éˆ•
        document.getElementById('schedule-task').addEventListener('click', () => {
            this.showScheduleDialog();
        });

        // æ’­æ”¾éŸ³é »æŒ‰éˆ•
        document.getElementById('play-audio').addEventListener('click', () => {
            this.playAudio();
        });

        // æŸ¥çœ‹åŸæ–‡æŒ‰éˆ•
        document.getElementById('view-references').addEventListener('click', () => {
            this.showReferences();
        });
    }

    async createTask(scheduleType = 'immediate') {
        try {
            // é¡¯ç¤ºè¼‰å…¥ç‹€æ…‹
            this.showStatus('æ­£åœ¨è™•ç†æ‚¨çš„è«‹æ±‚...');

            // æ”¶é›†ç”¨æˆ¶è¼¸å…¥
            const taskData = this.collectTaskData(scheduleType);

            // é©—è­‰è¼¸å…¥
            if (!this.validateInput(taskData)) {
                return;
            }

            // ç™¼é€APIè«‹æ±‚
            const response = await this.sendApiRequest('/tasks', 'POST', taskData);

            if (response.success) {
                // å¦‚æœæ˜¯ç«‹å³åŸ·è¡Œï¼Œè¼ªè©¢çµæœ
                if (scheduleType === 'immediate') {
                    await this.pollTaskResult(response.data.taskId);
                } else {
                    this.showSuccess('æ’ç¨‹ä»»å‹™å·²å‰µå»ºæˆåŠŸï¼');
                }
            } else {
                throw new Error(response.error.message);
            }

        } catch (error) {
            this.showError('è™•ç†å¤±æ•—ï¼š' + error.message);
        }
    }

    collectTaskData(scheduleType) {
        const urls = document.getElementById('urls').value
            .split('\\n')
            .filter(url => url.trim())
            .map(url => url.trim());

        const promptType = document.getElementById('prompt').value;
        const customText = document.getElementById('custom-text').value;

        let customPrompt = '';
        switch (promptType) {
            case 'business':
                customPrompt = 'è«‹å¾å•†æ¥­è§’åº¦åˆ†æé€™äº›æ–°èï¼Œé‡é»é—œæ³¨å¸‚å ´å½±éŸ¿ã€å•†æ©Ÿå’Œé¢¨éšª';
                break;
            case 'technical':
                customPrompt = 'è«‹å¾æŠ€è¡“è§’åº¦è§£è®€é€™äº›æ–°èï¼Œé‡é»é—œæ³¨æŠ€è¡“å‰µæ–°å’Œç™¼å±•è¶¨å‹¢';
                break;
            case 'general':
                customPrompt = 'è«‹æä¾›é€™äº›æ–°èçš„é‡é»æ‘˜è¦ï¼ŒåŒ…å«ä¸»è¦äº‹ä»¶å’Œå½±éŸ¿';
                break;
            case 'custom':
                customPrompt = customText;
                break;
        }

        return {
            urls,
            customPrompt,
            scheduleType,
            preferences: {
                summaryLength: 'medium',
                voiceEnabled: true,
                language: 'zh-TW'
            }
        };
    }

    validateInput(taskData) {
        if (!taskData.urls.length) {
            this.showError('è«‹è¼¸å…¥è‡³å°‘ä¸€å€‹æ–°èç¶²å€');
            return false;
        }

        if (taskData.urls.length > 10) {
            this.showError('ä¸€æ¬¡æœ€å¤šåªèƒ½è™•ç†10å€‹ç¶²å€');
            return false;
        }

        // é©—è­‰URLæ ¼å¼
        const urlPattern = /^https?:\\/\\/.+/;
        const invalidUrls = taskData.urls.filter(url => !urlPattern.test(url));
        if (invalidUrls.length) {
            this.showError('è«‹ç¢ºèªç¶²å€æ ¼å¼æ­£ç¢ºï¼ˆéœ€è¦åŒ…å«http://æˆ–https://ï¼‰');
            return false;
        }

        return true;
    }

    async sendApiRequest(endpoint, method, data = null) {
        const options = {
            method,
            headers: {
                'Content-Type': 'application/json',
            }
        };

        if (data) {
            options.body = JSON.stringify(data);
        }

        const response = await fetch(this.apiBaseUrl + endpoint, options);
        return await response.json();
    }

    async pollTaskResult(taskId) {
        const maxAttempts = 30; // æœ€å¤šç­‰å¾…5åˆ†é˜
        let attempts = 0;

        const poll = async () => {
            try {
                const response = await this.sendApiRequest(`/tasks/${taskId}/result`, 'GET');

                if (response.success) {
                    const { status, result } = response.data;

                    if (status === 'completed') {
                        this.showResult(result);
                        return;
                    } else if (status === 'failed') {
                        throw new Error('ä»»å‹™åŸ·è¡Œå¤±æ•—');
                    } else if (status === 'processing') {
                        // ç¹¼çºŒç­‰å¾…
                        attempts++;
                        if (attempts < maxAttempts) {
                            setTimeout(poll, 10000); // æ¯10ç§’æª¢æŸ¥ä¸€æ¬¡
                        } else {
                            throw new Error('ä»»å‹™åŸ·è¡Œè¶…æ™‚');
                        }
                    }
                } else {
                    throw new Error(response.error.message);
                }
            } catch (error) {
                this.showError('æŸ¥è©¢çµæœå¤±æ•—ï¼š' + error.message);
            }
        };

        poll();
    }

    showStatus(message) {
        const statusDiv = document.getElementById('status');
        const resultDiv = document.getElementById('result');

        statusDiv.querySelector('span').textContent = message;
        statusDiv.classList.remove('hidden');
        resultDiv.classList.add('hidden');
    }

    showResult(result) {
        const statusDiv = document.getElementById('status');
        const resultDiv = document.getElementById('result');
        const summaryText = document.getElementById('summary-text');

        // éš±è—è¼‰å…¥ç‹€æ…‹
        statusDiv.classList.add('hidden');

        // é¡¯ç¤ºçµæœ
        summaryText.textContent = result.summaryText;
        resultDiv.classList.remove('hidden');

        // å„²å­˜çµæœæ•¸æ“šä¾›å…¶ä»–åŠŸèƒ½ä½¿ç”¨
        this.currentResult = result;
    }

    showError(message) {
        const statusDiv = document.getElementById('status');
        statusDiv.innerHTML = `
            <div class=\"error\">
                <span style=\"color: #ff6b6b;\">âŒ ${message}</span>
            </div>
        `;
        statusDiv.classList.remove('hidden');

        // 3ç§’å¾Œéš±è—éŒ¯èª¤è¨Šæ¯
        setTimeout(() => {
            statusDiv.classList.add('hidden');
        }, 3000);
    }

    showSuccess(message) {
        const statusDiv = document.getElementById('status');
        statusDiv.innerHTML = `
            <div class=\"success\">
                <span style=\"color: #4CAF50;\">âœ… ${message}</span>
            </div>
        `;
        statusDiv.classList.remove('hidden');

        setTimeout(() => {
            statusDiv.classList.add('hidden');
        }, 3000);
    }

    playAudio() {
        if (this.currentResult && this.currentResult.audioUrl) {
            const audio = new Audio(this.currentResult.audioUrl);
            audio.play().catch(error => {
                this.showError('èªéŸ³æ’­æ”¾å¤±æ•—ï¼š' + error.message);
            });
        }
    }

    showReferences() {
        if (this.currentResult && this.currentResult.references) {
            // åœ¨æ–°æ¨™ç±¤é ä¸­é¡¯ç¤ºåŸæ–‡é€£çµ
            this.currentResult.references.forEach(ref => {
                window.open(ref.url, '_blank');
            });
        }
    }

    async loadUserPreferences() {
        try {
            // å¾Chrome storageè¼‰å…¥ç”¨æˆ¶åå¥½
            const result = await chrome.storage.sync.get(['userPreferences']);
            if (result.userPreferences) {
                this.applyPreferences(result.userPreferences);
            }
        } catch (error) {
            console.log('è¼‰å…¥ç”¨æˆ¶åå¥½å¤±æ•—ï¼š', error);
        }
    }

    applyPreferences(preferences) {
        // æ ¹æ“šåå¥½è¨­å®šèª¿æ•´UI
        if (preferences.defaultPrompt) {
            document.getElementById('prompt').value = preferences.defaultPrompt;
        }
    }

    showScheduleDialog() {
        // é€™è£¡å¯ä»¥é¡¯ç¤ºæ’ç¨‹è¨­å®šå°è©±æ¡†
        // ç‚ºäº†ç°¡åŒ–ï¼Œæš«æ™‚ä½¿ç”¨confirm
        const schedule = confirm('æ˜¯å¦è¨­å®šç‚ºæ¯é€±ä¸€ä¸Šåˆ9é»åŸ·è¡Œï¼Ÿ');
        if (schedule) {
            this.createTask('weekly');
        }
    }
}

// ç•¶é é¢è¼‰å…¥å®Œæˆæ™‚åˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', () => {
    new NewsExtension();
});
```

### ğŸƒâ€â™‚ï¸ ç¬¬äºŒé€±ï¼šå¾Œç«¯APIé–‹ç™¼

#### Day 8-10: Express.js å¾Œç«¯æ¶æ§‹
å»ºç«‹ `backend/app.js`ï¼š
```javascript
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');

const tasksRouter = require('./routes/tasks');
const usersRouter = require('./routes/users');
const { errorHandler } = require('./middleware/errorHandler');
const { requestLogger } = require('./middleware/logger');

const app = express();

// å®‰å…¨ä¸­é–“ä»¶
app.use(helmet());
app.use(cors({
    origin: ['chrome-extension://*', 'http://localhost:*'],
    credentials: true
}));

// è«‹æ±‚é™åˆ¶
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15åˆ†é˜
    max: 100, // æœ€å¤š100æ¬¡è«‹æ±‚
    message: 'è«‹æ±‚éæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦'
});
app.use('/api/', limiter);

// åŸºç¤ä¸­é–“ä»¶
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));
app.use(requestLogger);

// è·¯ç”±
app.use('/api/v1/tasks', tasksRouter);
app.use('/api/v1/users', usersRouter);

// å¥åº·æª¢æŸ¥
app.get('/health', (req, res) => {
    res.json({
        status: 'healthy',
        timestamp: new Date().toISOString(),
        version: process.env.npm_package_version || '1.0.0'
    });
});

// éŒ¯èª¤è™•ç†
app.use(errorHandler);

// 404è™•ç†
app.use('*', (req, res) => {
    res.status(404).json({
        success: false,
        error: {
            code: 'NOT_FOUND',
            message: 'æ‰¾ä¸åˆ°è«‹æ±‚çš„è³‡æº'
        }
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`ğŸš€ ä¼ºæœå™¨é‹è¡Œåœ¨ http://localhost:${PORT}`);
});

module.exports = app;
```

å»ºç«‹ `backend/routes/tasks.js`ï¼š
```javascript
const express = require('express');
const router = express.Router();
const TaskService = require('../services/TaskService');
const { validateTaskInput } = require('../middleware/validation');

// å‰µå»ºæ–°ä»»å‹™
router.post('/', validateTaskInput, async (req, res, next) => {
    try {
        const taskData = {
            urls: req.body.urls,
            customPrompt: req.body.customPrompt,
            scheduleType: req.body.scheduleType || 'immediate',
            preferences: req.body.preferences || {}
        };

        const result = await TaskService.createTask(taskData);

        res.status(201).json({
            success: true,
            data: {
                taskId: result.taskId,
                status: result.status,
                estimatedCompletionTime: result.estimatedCompletionTime,
                message: 'ä»»å‹™å·²æˆåŠŸå‰µå»º'
            }
        });
    } catch (error) {
        next(error);
    }
});

// æŸ¥è©¢ä»»å‹™çµæœ
router.get('/:taskId/result', async (req, res, next) => {
    try {
        const { taskId } = req.params;
        const result = await TaskService.getTaskResult(taskId);

        if (!result) {
            return res.status(404).json({
                success: false,
                error: {
                    code: 'TASK_NOT_FOUND',
                    message: 'æ‰¾ä¸åˆ°æŒ‡å®šçš„ä»»å‹™'
                }
            });
        }

        res.json({
            success: true,
            data: result
        });
    } catch (error) {
        next(error);
    }
});

// å–æ¶ˆä»»å‹™
router.delete('/:taskId', async (req, res, next) => {
    try {
        const { taskId } = req.params;
        await TaskService.cancelTask(taskId);

        res.status(204).send();
    } catch (error) {
        next(error);
    }
});

module.exports = router;
```

#### Day 11-14: æ ¸å¿ƒæœå‹™å¯¦ä½œ
å»ºç«‹ `backend/services/TaskService.js`ï¼š
```javascript
const { v4: uuidv4 } = require('uuid');
const CrawlerService = require('./CrawlerService');
const AIService = require('./AIService');
const VoiceService = require('./VoiceService');
const DatabaseService = require('./DatabaseService');

class TaskService {
    static async createTask(taskData) {
        const taskId = uuidv4();

        // å„²å­˜ä»»å‹™åˆ°è³‡æ–™åº«
        const task = {
            taskId,
            urls: taskData.urls,
            customPrompt: taskData.customPrompt,
            scheduleType: taskData.scheduleType,
            status: 'pending',
            createdAt: new Date()
        };

        await DatabaseService.saveTask(task);

        // å¦‚æœæ˜¯ç«‹å³åŸ·è¡Œï¼Œå•Ÿå‹•è™•ç†æµç¨‹
        if (taskData.scheduleType === 'immediate') {
            // ç•°æ­¥è™•ç†ï¼Œä¸é˜»å¡å›æ‡‰
            this.processTask(taskId).catch(error => {
                console.error(`ä»»å‹™ ${taskId} è™•ç†å¤±æ•—:`, error);
                DatabaseService.updateTaskStatus(taskId, 'failed', { error: error.message });
            });
        }

        return {
            taskId,
            status: 'pending',
            estimatedCompletionTime: this.calculateEstimatedTime(taskData.urls.length)
        };
    }

    static async processTask(taskId) {
        console.log(`é–‹å§‹è™•ç†ä»»å‹™: ${taskId}`);

        try {
            // æ›´æ–°ç‹€æ…‹ç‚ºè™•ç†ä¸­
            await DatabaseService.updateTaskStatus(taskId, 'processing');

            // å–å¾—ä»»å‹™è©³æƒ…
            const task = await DatabaseService.getTask(taskId);
            if (!task) {
                throw new Error('æ‰¾ä¸åˆ°ä»»å‹™');
            }

            // ç¬¬ä¸€æ­¥ï¼šçˆ¬å–ç¶²é å…§å®¹
            console.log(`çˆ¬å– ${task.urls.length} å€‹ç¶²å€çš„å…§å®¹...`);
            const articles = await CrawlerService.fetchArticles(task.urls);

            if (!articles.length) {
                throw new Error('ç„¡æ³•ç²å–ä»»ä½•æœ‰æ•ˆå…§å®¹');
            }

            // ç¬¬äºŒæ­¥ï¼šç”Ÿæˆæ‘˜è¦
            console.log('ç”ŸæˆAIæ‘˜è¦...');
            const summaryText = await AIService.generateSummary(articles, task.customPrompt);

            // ç¬¬ä¸‰æ­¥ï¼šç”ŸæˆèªéŸ³
            console.log('ç”ŸæˆèªéŸ³æª”æ¡ˆ...');
            const audioUrl = await VoiceService.textToSpeech(summaryText);

            // ç¬¬å››æ­¥ï¼šå„²å­˜çµæœ
            const result = {
                taskId,
                summaryText,
                audioUrl,
                references: articles.map(article => ({
                    title: article.title,
                    url: article.url,
                    publishedAt: article.publishedAt
                })),
                metadata: {
                    wordCount: summaryText.length,
                    processingTimeMs: Date.now() - task.createdAt.getTime(),
                    aiModelUsed: 'gpt-3.5-turbo'
                }
            };

            await DatabaseService.saveTaskResult(result);
            await DatabaseService.updateTaskStatus(taskId, 'completed');

            console.log(`ä»»å‹™ ${taskId} è™•ç†å®Œæˆ`);

        } catch (error) {
            console.error(`ä»»å‹™ ${taskId} è™•ç†å¤±æ•—:`, error);
            await DatabaseService.updateTaskStatus(taskId, 'failed', { error: error.message });
            throw error;
        }
    }

    static async getTaskResult(taskId) {
        const task = await DatabaseService.getTask(taskId);
        if (!task) {
            return null;
        }

        const result = {
            taskId,
            status: task.status
        };

        if (task.status === 'completed') {
            const taskResult = await DatabaseService.getTaskResult(taskId);
            result.result = taskResult;
            result.completedAt = task.completedAt;
        } else if (task.status === 'failed') {
            result.error = task.errorDetails;
        }

        return result;
    }

    static async cancelTask(taskId) {
        await DatabaseService.updateTaskStatus(taskId, 'cancelled');
    }

    static calculateEstimatedTime(urlCount) {
        // ä¼°ç®—è™•ç†æ™‚é–“ï¼šæ¯å€‹URLç´„30ç§’
        const estimatedSeconds = urlCount * 30;
        return new Date(Date.now() + estimatedSeconds * 1000).toISOString();
    }
}

module.exports = TaskService;
```

é€™æ¨£æˆ‘å€‘å°±æœ‰äº†ä¸€å€‹å®Œæ•´çš„å¯¦ä½œæŒ‡å—ï¼Œå¾Chromeæ’ä»¶å‰ç«¯åˆ°Express.jså¾Œç«¯çš„å®Œæ•´å¯¦ç¾ï¼

---
*è¨˜ä½ï¼šå¥½çš„ç¨‹å¼ç¢¼æ˜¯ä¸€æ­¥æ­¥å¯«å‡ºä¾†çš„ï¼Œä¸è¦æ€¥æ–¼ä¸€æ¬¡åšå®Œæ‰€æœ‰åŠŸèƒ½ï¼*