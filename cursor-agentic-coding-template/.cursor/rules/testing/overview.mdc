---
description: Defines the project's testing strategy, including the testing pyramid, TDD/BDD methodology, and code coverage standards.
globs:
  - "**/*.test.ts"
  - "**/*.test.js"
  - "**/*.spec.ts"
  - "**/*.spec.js"
  - "tests/**/*"
  - "__tests__/**/*"
  - "cypress/**/*"
  - "e2e/**/*"
---

# 🎯 測試策略

## 測試金字塔
```
      /\
     /E2E\     (10%) - 關鍵使用者流程
    /------\
   /Integration\ (30%) - API、資料庫整合
  /------------\
 / Unit Tests   \ (60%) - 函數、元件邏輯
/________________\
```

## 測試覆蓋率要求
- **整體覆蓋率**: >= 80%
- **關鍵模組**: >= 90%
- **新程式碼**: >= 95%
- **分支覆蓋**: >= 75%

# 🔬 單元測試

## 測試結構 (AAA Pattern)
```typescript
describe('ComponentName', () => {
  // Arrange: 設定測試環境
  let component: ComponentType

  beforeEach(() => {
    // 初始化
  })

  it('should do something specific', () => {
    // Arrange: 準備測試資料
    const input = { /* test data */ }

    // Act: 執行測試動作
    const result = component.method(input)

    // Assert: 驗證結果
    expect(result).toBe(expectedValue)
  })
})
```

## 測試命名規範
```typescript
// ✅ Good: 描述行為
it('should return user data when valid ID is provided')
it('should throw error when ID is invalid')
it('should update cache after successful fetch')

// ❌ Bad: 技術細節
it('test1')
it('returns object')
it('works')
```

## Mock 策略
```typescript
// 依賴注入優先
class UserService {
  constructor(
    private repo: IUserRepository,  // 易於 mock
    private cache: ICacheService
  ) {}
}

// Mock 外部依賴
jest.mock('./external-service', () => ({
  fetchData: jest.fn().mockResolvedValue(mockData)
}))

// Spy 內部方法
const spy = jest.spyOn(service, 'internalMethod')
```

# 🔗 整合測試

## API 測試
```typescript
describe('POST /api/users', () => {
  it('should create user with valid data', async () => {
    const response = await request(app)
      .post('/api/users')
      .send({
        email: 'test@example.com',
        name: 'Test User'
      })
      .expect(201)

    expect(response.body).toMatchObject({
      id: expect.any(String),
      email: 'test@example.com'
    })

    // 驗證副作用
    const user = await db.users.findById(response.body.id)
    expect(user).toBeDefined()
  })
})
```

## 資料庫測試
```typescript
beforeEach(async () => {
  // 使用 transaction 確保隔離
  await db.transaction.start()
})

afterEach(async () => {
  // 回滾確保清理
  await db.transaction.rollback()
})
```

# 🌐 E2E 測試

## Playwright/Cypress 最佳實踐
```typescript
// 使用 data-testid 而非 CSS selector
await page.click('[data-testid="submit-button"]')

// 等待條件而非固定時間
await page.waitForSelector('[data-testid="success-message"]')

// 驗證多個條件
await expect(page).toHaveURL('/dashboard')
await expect(page.locator('h1')).toContainText('Welcome')
```

## 關鍵使用者流程
```typescript
test('complete purchase flow', async ({ page }) => {
  // 1. 登入
  await loginUser(page, testUser)

  // 2. 選擇商品
  await page.goto('/products')
  await page.click('[data-testid="product-1"]')

  // 3. 加入購物車
  await page.click('[data-testid="add-to-cart"]')

  // 4. 結帳
  await page.goto('/checkout')
  await fillPaymentInfo(page, paymentData)
  await page.click('[data-testid="place-order"]')

  // 5. 驗證成功
  await expect(page).toHaveURL('/order-success')
})
```

# 🏃 測試效能

## 平行執行
```javascript
// Jest 配置
module.exports = {
  maxWorkers: '50%',  // 使用 50% CPU
  testTimeout: 10000,  // 10 秒超時
}

// 避免測試間依賴
beforeEach(() => {
  jest.clearAllMocks()
  jest.resetModules()
})
```

## 測試資料管理
```typescript
// Factory Pattern 建立測試資料
class UserFactory {
  static create(overrides = {}) {
    return {
      id: faker.datatype.uuid(),
      email: faker.internet.email(),
      name: faker.name.findName(),
      ...overrides
    }
  }
}

// Fixtures 重用
const fixtures = {
  validUser: UserFactory.create(),
  adminUser: UserFactory.create({ role: 'admin' })
}
```

# 📊 測試報告

## Coverage 報告設定
```json
{
  "jest": {
    "collectCoverage": true,
    "coverageDirectory": "coverage",
    "coverageReporters": ["text", "lcov", "html"],
    "coverageThreshold": {
      "global": {
        "branches": 75,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    }
  }
}
```

## 測試文件
```typescript
/**
 * @group unit
 * @group critical
 */
describe('PaymentService', () => {
  /**
   * Test: 確保付款處理正確
   * Requirement: REQ-PAY-001
   * Risk: High - 涉及金流
   */
  it('should process payment correctly', () => {
    // ...
  })
})
```

# ⚡ 測試優化

## 避免的模式
```typescript
// ❌ 測試實作細節
expect(component.state.isLoading).toBe(true)

// ✅ 測試行為
expect(screen.getByTestId('loader')).toBeInTheDocument()

// ❌ 過度 mock
jest.mock('entire-module')

// ✅ 最小必要 mock
jest.mock('./api', () => ({
  fetchUser: jest.fn()
}))

// ❌ 脆弱的測試
expect(html).toContain('<div class="btn btn-primary">')

// ✅ 穩定的測試
expect(screen.getByRole('button')).toHaveClass('primary')
```

## 測試隔離
```typescript
// 每個測試獨立執行
describe.each([
  [1, 1, 2],
  [2, 3, 5],
  [5, 8, 13]
])('add(%i, %i)', (a, b, expected) => {
  test(`returns ${expected}`, () => {
    expect(add(a, b)).toBe(expected)
  })
})
```

# 🔍 Debug 技巧

## 測試除錯
```typescript
// 只執行特定測試
it.only('should focus on this test', () => {})

// 跳過測試
it.skip('should skip this test', () => {})

// 條件測試
it.skipIf(process.env.CI)('local only test', () => {})

// Debug 輸出
test('debug test', () => {
  console.log('Current state:', component.debug())
  screen.debug()  // React Testing Library
})
```

## 快照測試
```typescript
// 適合用於
- 錯誤訊息
- 配置物件
- API 回應結構

// 不適合用於
- 經常變動的 UI
- 時間戳記
- 隨機資料
```

# 🚫 測試禁忌

## 絕對不可以
- ❌ 測試依賴執行順序
- ❌ 共享可變狀態
- ❌ 硬編碼等待時間
- ❌ 測試私有方法
- ❌ 在測試中呼叫真實 API
- ❌ 忽略 flaky tests

## 必須要做
- ✅ 每個測試獨立
- ✅ 清理測試資料
- ✅ 使用有意義的斷言訊息
- ✅ 測試邊界條件
- ✅ 測試錯誤情況
- ✅ 保持測試簡單